<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Retro Bouncing Balls</title>
  <style>
    body {
      margin: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      background: radial-gradient(circle at 20% 20%, #050014, #000);
      color: #f0f6ff;
      font-family: "Trebuchet MS", Arial, sans-serif;
    }
    canvas {
      border: 4px solid rgba(0, 255, 213, 0.7);
      border-radius: 18px;
      background: linear-gradient(160deg, rgba(10, 0, 30, 0.95), rgba(0, 0, 0, 0.9));
      box-shadow: 0 18px 36px rgba(0, 0, 0, 0.6), 0 0 28px rgba(0, 255, 213, 0.35);
    }
    .message {
      position: absolute;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 12px 26px;
      border-radius: 999px;
      background: rgba(0, 255, 213, 0.16);
      border: 1px solid rgba(0, 255, 213, 0.4);
      box-shadow: 0 0 18px rgba(0, 255, 213, 0.45);
      font-weight: 700;
      font-size: 1.05rem;
      letter-spacing: 0.24em;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.92);
      pointer-events: none;
      mix-blend-mode: screen;
    }
    .badge {
      position: absolute;
      top: 30px;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      font-size: 0.75rem;
      color: rgba(0, 255, 213, 0.75);
    }
  </style>
</head>
<body>
  <div class="badge">five-ball retro collider</div>
  <div class="message" id="birthday">Happy Anniversary to Ranjit</div>
  <canvas id="playfield" width="900" height="520"></canvas>
  <script>
    const canvas = document.getElementById("playfield");
    const ctx = canvas.getContext("2d");

    class Ball {
      constructor({ x, y, radius, color, vx, vy, shape = "circle" }) {
        Object.assign(this, { x, y, radius, color, vx, vy, shape });
        this.mass = radius * radius;
      }
      update(bounds, dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;

        if (this.x - this.radius < 0) {
          this.x = this.radius;
          this.vx *= -1;
        } else if (this.x + this.radius > bounds.width) {
          this.x = bounds.width - this.radius;
          this.vx *= -1;
        }

        if (this.y - this.radius < 0) {
          this.y = this.radius;
          this.vy *= -1;
        } else if (this.y + this.radius > bounds.height) {
          this.y = bounds.height - this.radius;
          this.vy *= -1;
        }
      }
      draw(ctx) {
        if (this.shape === "diamond") {
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(Math.PI / 4);
          const side = this.radius * Math.sqrt(2);
          ctx.fillStyle = this.color;
          ctx.fillRect(-side, -side, side * 2, side * 2);
          ctx.restore();
          return;
        }

        if (this.shape === "baseball") {
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.beginPath();
          ctx.fillStyle = "#fff";
          ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = "#d22";
          ctx.lineWidth = Math.max(1.4, this.radius * 0.12);
          const seamOffset = this.radius * 0.65;

          ctx.beginPath();
          ctx.arc(-seamOffset * 0.55, 0, this.radius * 0.85, -Math.PI / 2, Math.PI / 2);
          ctx.stroke();

          ctx.beginPath();
          ctx.arc(seamOffset * 0.55, 0, this.radius * 0.85, Math.PI / 2, -Math.PI / 2);
          ctx.stroke();

          ctx.lineWidth = Math.max(1, this.radius * 0.08);
          const stitches = 6;
          for (let i = 0; i < stitches; i += 1) {
            const angle = (i / (stitches - 1)) * Math.PI - Math.PI / 2;
            const x = -seamOffset * 0.55 + Math.cos(angle) * this.radius * 0.85;
            const y = Math.sin(angle) * this.radius * 0.85;
            ctx.beginPath();
            ctx.moveTo(x - this.radius * 0.18, y - this.radius * 0.04);
            ctx.lineTo(x + this.radius * 0.18, y + this.radius * 0.04);
            ctx.stroke();

            const x2 = seamOffset * 0.55 - Math.cos(angle) * this.radius * 0.85;
            const y2 = Math.sin(angle) * this.radius * 0.85;
            ctx.beginPath();
            ctx.moveTo(x2 - this.radius * 0.18, y2 + this.radius * 0.04);
            ctx.lineTo(x2 + this.radius * 0.18, y2 - this.radius * 0.04);
            ctx.stroke();
          }
        ctx.restore();
        return;
      }

      if (this.shape === "portrait") {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.closePath();

        if (Ball.portrait.complete && Ball.portrait.naturalWidth) {
          ctx.clip();
          ctx.drawImage(Ball.portrait, -this.radius, -this.radius, this.radius * 2, this.radius * 2);
        } else {
          ctx.fillStyle = "#ffffff";
          ctx.fill();
        }
        ctx.restore();
          return;
        }

      if (this.shape === "logo") {
        ctx.save();
        ctx.translate(this.x, this.y);
        const logoWidth = this.radius * 1.4;
        const logoHeight = this.radius * 0.9;
        if (Ball.logo.complete && Ball.logo.naturalWidth) {
          ctx.fillStyle = "#ffffff";
          ctx.fillRect(-logoWidth, -logoHeight, logoWidth * 2, logoHeight * 2);
          ctx.drawImage(Ball.logo, -logoWidth, -logoHeight, logoWidth * 2, logoHeight * 2);
        } else {
          ctx.fillStyle = "#004f9e";
          ctx.fillRect(-logoWidth, -logoHeight, logoWidth * 2, logoHeight * 2);
        }
        ctx.restore();
        return;
      }

        ctx.beginPath();
        ctx.fillStyle = this.color;
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    Ball.portrait = new Image();
    Ball.portrait.src = "assets/bilal-birthday.jpeg";
    Ball.logo = new Image();
    Ball.logo.src = "assets/berkeley-logo.png";

    function resolveBallCollision(a, b) {
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const minDistance = a.radius + b.radius;
      const distanceSq = dx * dx + dy * dy;
      if (distanceSq >= minDistance * minDistance) {
        return;
      }

      const distance = Math.sqrt(distanceSq) || minDistance;
      const nx = dx / distance;
      const ny = dy / distance;
      const overlap = minDistance - distance;

      if (overlap > 0) {
        const totalMass = a.mass + b.mass;
        const correction = overlap / totalMass;
        a.x -= nx * correction * b.mass;
        a.y -= ny * correction * b.mass;
        b.x += nx * correction * a.mass;
        b.y += ny * correction * a.mass;
      }

      const tx = -ny;
      const ty = nx;

      const v1n = a.vx * nx + a.vy * ny;
      const v1t = a.vx * tx + a.vy * ty;
      const v2n = b.vx * nx + b.vy * ny;
      const v2t = b.vx * tx + b.vy * ty;

      const restitution = 0.97;
      const totalMass = a.mass + b.mass;
      const v1nAfter = ((a.mass - b.mass) * v1n + 2 * b.mass * v2n) / totalMass;
      const v2nAfter = ((b.mass - a.mass) * v2n + 2 * a.mass * v1n) / totalMass;

      const v1nFinal = v1nAfter * restitution;
      const v2nFinal = v2nAfter * restitution;

      a.vx = tx * v1t + nx * v1nFinal;
      a.vy = ty * v1t + ny * v1nFinal;
      b.vx = tx * v2t + nx * v2nFinal;
      b.vy = ty * v2t + ny * v2nFinal;
    }

    const bounds = { width: canvas.width, height: canvas.height };
    const balls = [
      new Ball({ x: 160, y: 160, radius: 22, color: "#ff355e", vx: 3.4, vy: 2.6 }),
      new Ball({ x: 300, y: 120, radius: 28, color: "#3478f6", vx: -2.4, vy: 3.2, shape: "baseball" }),
      new Ball({ x: 480, y: 280, radius: 24, color: "#53fcb2", vx: 2.6, vy: -2.8 }),
      new Ball({ x: 640, y: 180, radius: 26, color: "#ffa552", vx: -3.1, vy: -2.3 }),
      new Ball({ x: 720, y: 120, radius: 72, color: "#004f9e", vx: -2.2, vy: 3.1, shape: "logo" }),
      new Ball({ x: 820, y: 340, radius: 34, color: "#ffffff", vx: 3.0, vy: 2.6, shape: "portrait" }),
    ];

    const SUB_STEPS = 8;
    const COLLISION_ITERATIONS = 3;

    function stepSimulation() {
      const dt = 1 / SUB_STEPS;
      for (let step = 0; step < SUB_STEPS; step += 1) {
        balls.forEach(ball => ball.update(bounds, dt));

        for (let iter = 0; iter < COLLISION_ITERATIONS; iter += 1) {
          for (let i = 0; i < balls.length; i += 1) {
            for (let j = i + 1; j < balls.length; j += 1) {
              resolveBallCollision(balls[i], balls[j]);
            }
          }
        }
      }
    }

    function animate() {
      ctx.clearRect(0, 0, bounds.width, bounds.height);
      stepSimulation();
      balls.forEach(ball => ball.draw(ctx));
      requestAnimationFrame(animate);
    }

    animate();

    const birthday = document.getElementById("birthday");
    (function floatMessage() {
      let phase = 0;
      function step() {
        phase += 0.025;
        const x = canvas.offsetLeft + canvas.width / 2 - birthday.offsetWidth / 2 + Math.sin(phase * 1.5) * 120;
        const y = canvas.offsetTop + canvas.height / 2 - birthday.offsetHeight / 2 + Math.cos(phase) * 40;
        birthday.style.left = `${x}px`;
        birthday.style.top = `${y}px`;
        birthday.style.opacity = 0.7 + Math.sin(phase * 3) * 0.25;
        birthday.style.transform = `scale(${0.98 + Math.sin(phase * 4) * 0.03})`;
        requestAnimationFrame(step);
      }
      step();
    }());
  </script>
</body>
</html>
